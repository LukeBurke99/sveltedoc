/*
	sync-docs.ts — Component doc block synchronizer for Svelte 5 components

	Purpose
	- This script prints a concise timing line, e.g., "[docs:sync] src/components/Core/Alert.svelte (updated) in 42.5ms".
		- Recommended: use a "run on save" tool/extension to execute: pnpm docs:sync ${file}
import { readFile, stat, writeFile } from 'node:fs/promises'; // Ensure no eslint errors
		- This script prints a concise timing line, e.g., "[docs:sync] src/components/Core/Alert.svelte (updated) in 42.5ms".

import { performance } from 'node:perf_hooks'; // Ensure no eslint errors
import { performance } from 'node:perf_hooks';
	- Reads the provided .svelte file and concatenates all <script lang="ts"> blocks (both regular and module).
	- Locates the $props() destructuring to discover prop names, detect $bindable(...), and capture defaults.
	- Locates the type alias used for the destructuring (e.g., Props, ButtonProps), including exported aliases.
	- Parses the type alias right-hand side:
			• Splits top-level intersection (&) into:
				- Object literal parts: source of declared prop names, their types and optionality.
				- Non-object parts: listed as "Inherits" (e.g., HTMLAttributes<HTMLDivElement>, Omit<...>, CustomProps).
			• Extracts inline JSDoc for each property as its short description (first paragraph flattened).
	- Renders a single @component block with the exact format below and inserts it before the first <script> block
		(replacing any previous header content), preserving the current description if present.

	Output format (single block, no duplicates)
		<!-- @component
		## ComponentName
		{Description text, preserved between runs. Default: "no description yet"}
		### Props
		#### Inherits: `Type1` & `Type2` & `Type3`           (line omitted if no inherits)
		- `! name` **Type** = `default` — Description           (! for required, $ for bindable)
		- `$ name` **Type** = `inner` — Description            (default shows the inner of $bindable(inner))
		- `name` **Type** — Description                         (optional props have no extra marker)
		-->

	Markers and rules
	- Required prop: prefixed with "! ". Determined by the absence of ? in the type declaration.
	- Bindable prop: prefixed with "$ ". Determined by a default initializer that calls $bindable(...).
	- Default value: displayed as literal inside backticks. If using $bindable(inner), the shown default is inner.
	- Inherits: every non-object node in the Props intersection printed inline, each inside backticks and joined by " & ".
	- Escaping: In plain text (e.g., description), < and > are escaped as &lt; and &gt;. Inside code spans (backticks), values
							are not escaped so types like HTMLDivElement and function signatures display correctly.

	Description persistence
	- If an existing @component block is found before the first <script lang="ts"> tag, the description is read as the content
		between the "## ComponentName" heading and the following "### Props" heading, and is preserved across runs.
	- If none exists, description defaults to "no description yet".

	Inputs/Outputs (contract)
	- Input: a single .svelte file path (absolute or relative). The command exits with a usage message if missing.
	- Output: the same file updated in-place with a fresh @component block at the top of the file.
	- Non-goals: does not process multiple files; does not attempt to parse runtime logic; does not write examples.

	Supported patterns
	- Props alias names like Props, ButtonProps, etc., including exported aliases.
	- Mixed module and non-module <script lang="ts"> blocks; types may be declared in either.
	- Intersections like: HTMLAttributes<HTMLDivElement> & { message: string; title?: string }
	- Inline JSDoc on properties for short descriptions.

	Implementation notes
	- Uses robust string/regex parsing instead of a full TypeScript AST for speed and portability (no external AST deps).
	- Splitting logic is "top-level aware" (respects (), {}, [], <> nesting and strings) for intersections and destructuring.
	- The entire header before the first <script lang="ts"> is replaced with the new comment to avoid duplication.

		Usage
		pnpm docs:sync path/to/Component.svelte
	- The script only operates on the specified file and requires the file to end with .svelte.

		On-save integration (VS Code)
		- Recommended: use a "run on save" tool/extension to execute: pnpm docs:sync ${file}
		- Scope the match to your components folder (e.g., src/components/**\/*.svelte) so only component saves trigger it.
		- This script prints a concise timing line, e.g., "[docs:sync] src/components/Core/Alert.svelte in 42.5ms".

	Edge cases and limitations
	- Very complex type expressions may require adjustments to the lightweight parser.
	- If no type alias is found, but defaults exist in destructuring, the script will still list props with type "unknown".
	- The comment must live before the first <script lang="ts"> tag to be recognized for description persistence.
*/

import { readFile, stat, writeFile } from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
// Intentionally avoiding heavy AST libraries to keep this script portable and fast.

type PropDoc = {
	name: string;
	typeText: string;
	optional: boolean;
	defaultText?: string;
	bindable: boolean;
	description?: string;
};

type ExtractResult = {
	inferredTypeName?: string;
	props: PropDoc[];
	inherits: string[];
	hasRest: boolean;
	debug: string[];
};

const START_MARK = '<!-- @component';

async function main(): Promise<void> {
	const t0 = performance.now();
	const targetArg = process.argv[2];
	if (!targetArg) {
		console.error('Usage: pnpm docs:sync <relative-or-absolute-path-to-.svelte>');
		process.exitCode = 1;
		return;
	}

	const filePath = path.resolve(targetArg);
	try {
		const s = await stat(filePath);
		if (!s.isFile() || !filePath.endsWith('.svelte')) {
			console.error('The provided path must be a .svelte file.');
			process.exitCode = 1;
			return;
		}
	} catch {
		console.error(`File not found: ${filePath}`);
		process.exitCode = 1;
		return;
	}

	const source = await readFile(filePath, 'utf8');
	const {
		scripts,
		leadingComment
	}: { scripts: string[]; leadingComment?: { raw: string; description: string } } =
		extractScriptsAndLeadingComment(source);

	const combinedTS = scripts.join('\n\n');
	const extract = extractDocsFromTS(combinedTS);

	const newComment = buildComment({
		filePath,
		existingDescription: leadingComment?.description ?? '',
		inherits: extract.inherits,
		props: extract.props
	});

	const updated = insertOrUpdateComment(source, newComment);
	const changed = updated !== source;
	if (changed) await writeFile(filePath, updated, 'utf8');
	const t1 = performance.now();
	const rel = path.relative(process.cwd(), filePath).replace(/\\/g, '/');
	const label = changed ? '(updated)' : '(no change)';
	console.log(`[docs:sync] ${rel} ${label} in ${(t1 - t0).toFixed(1)}ms`);

	// Emit diagnostics if extraction failed, or when verbose mode is enabled
	const verbose = process.env.DOCS_SYNC_VERBOSE === '1';
	if (verbose || extract.props.length === 0) {
		for (const line of extract.debug) console.log(`[docs:sync] ${line}`);
		if (extract.props.length === 0)
			console.warn(
				'[docs:sync] No props extracted. Ensure typed destructuring like: const { ... }: Props = $props();'
			);
	}
}

function extractScriptsAndLeadingComment(source: string): {
	scripts: string[];
	leadingComment?: { raw: string; description: string };
	remaining: string;
} {
	const scripts: string[] = [];

	// Extract all <script lang="ts" ...> blocks (module or not)
	const scriptRegex = /<script\s+[^>]*lang\s*=\s*["']ts["'][^>]*>([\s\S]*?)<\/script>/gi;
	let m: RegExpExecArray | null;
	while ((m = scriptRegex.exec(source)) !== null) scripts.push(m[1]);

	// Extract the entire head before the first <script ...> for safe replacement
	const firstScriptIdx = source.search(/<script\s+[^>]*lang\s*=\s*["']ts["'][^>]*>/i);
	const head = firstScriptIdx === -1 ? source : source.slice(0, firstScriptIdx);
	let leadingComment: { raw: string; description: string } | undefined;
	if (/<!--\s*@component/i.test(head)) {
		const headTrim = head.trimStart();
		const description = extractDescriptionFromComment(headTrim);
		leadingComment = { raw: headTrim, description };
	}
	return { scripts, leadingComment, remaining: source };
}

function extractDocsFromTS(tsCode: string): ExtractResult {
	// 1) Find the destructuring like: let { ... }: TypeName = $props();
	const result: ExtractResult = {
		inferredTypeName: undefined,
		props: [],
		inherits: [],
		hasRest: false,
		debug: []
	};

	const destructMatch =
		/(?:const|let|var)\s*{([\s\S]*?)}\s*:\s*([A-Za-z_]\w*)\s*(?:<[^>]*?>)?\s*=\s*\$props\s*\(/m.exec(
			tsCode
		);
	const defaults = new Map<string, string>();
	const bindables = new Set<string>();
	let hasRest = false;
	let typeName: string | undefined;
	if (destructMatch) {
		const body = destructMatch[1];
		typeName = destructMatch[2];
		result.inferredTypeName = typeName;
		result.debug.push(`Found $props destructuring; type: ${typeName}`);
		const parts = splitTopLevel(body, ',');
		result.debug.push('Destructured fields: ' + String(parts.filter((p) => p.trim()).length));
		for (const raw of parts) {
			const item = raw.trim();
			if (!item) continue;
			if (item.startsWith('...')) {
				hasRest = true;
				continue;
			}
			// pattern: name [ : alias ] [= default]
			const [left, defaultRhs] = splitOnce(item, '=');
			const [maybeName] = splitOnce(left.trim(), ':');
			const name = maybeName.trim();
			if (defaultRhs !== undefined) {
				const def = defaultRhs.trim();
				defaults.set(name, def);
				if (/\$bindable\s*\(/.test(def)) bindables.add(name);
			}
		}
		if (hasRest) result.debug.push('Detected rest element in destructuring: ...rest');
		if (defaults.size > 0)
			result.debug.push(
				'Defaults found: ' +
					String(defaults.size) +
					'; bindables: ' +
					String(bindables.size)
			);
	} else {
		result.debug.push(
			'No typed $props destructuring matched. Expected: const/let { ... }: Props = $props(...)'
		);
	}
	result.hasRest = hasRest;

	// 2) Find the type alias block
	let typeBlock = typeName ? findTypeAliasBlock(tsCode, typeName) : undefined;
	if (!typeBlock) {
		// fallback: pick first *Props alias name (with optional generics) and then resolve via scanner
		const m = /(?:export\s+)?type\s+([A-Za-z_]\w*Props)\b\s*(?:<[^>]*?>)?\s*=/m.exec(tsCode);
		if (m) {
			typeName = m[1];
			result.inferredTypeName = typeName;
			typeBlock = findTypeAliasBlock(tsCode, typeName);
			if (typeBlock) result.debug.push(`Using fallback type alias: ${typeName}`);
		}
	}
	if (!typeBlock && typeName) result.debug.push(`Type alias not found for: ${typeName}`);
	if (typeBlock) result.debug.push('Type alias block resolved. Parsing members...');

	const props: PropDoc[] = [];
	const inherits: string[] = [];

	if (typeBlock) {
		const parts = splitIntersection(typeBlock);
		for (const part of parts) {
			const trimmed = part.trim();
			if (trimmed.startsWith('{')) {
				// object literal part
				const membersText = trimmed.slice(1, trimmed.lastIndexOf('}'));
				const members = parseTypeMembers(membersText);
				result.debug.push('Object members parsed: ' + String(members.length));
				for (const mem of members) {
					const defaultText = defaults.get(mem.name);
					const bindable = bindables.has(mem.name);
					props.push({
						name: mem.name,
						typeText: mem.typeText,
						optional: mem.optional,
						defaultText,
						bindable,
						description: mem.description
					});
				}
			} else {
				inherits.push(trimmed);
			}
		}
		if (inherits.length > 0) result.debug.push('Inherits detected: ' + String(inherits.length));
	}

	if (props.length === 0 && defaults.size > 0)
		for (const [name, def] of defaults) {
			const bindable = /\$bindable\s*\(/.test(def);
			props.push({ name, typeText: 'unknown', optional: false, defaultText: def, bindable });
		}

	props.sort((a, b) => {
		if (a.optional !== b.optional) return a.optional ? 1 : -1;
		return a.name.localeCompare(b.name);
	});

	result.props = props;
	result.inherits = dedupe(inherits);
	result.debug.push('Final props count: ' + String(props.length));
	return result;
}

function findTypeAliasBlock(tsCode: string, typeName: string): string | undefined {
	// Try to find either `export type Name =` or `type Name =`, allowing optional generic params: `type Name<T extends X> =`
	let re = new RegExp(
		String.raw`\bexport\s+type\s+${escapeRegExp(typeName)}\b\s*(?:<[^>]*?>)?\s*=`,
		'm'
	);
	let m = re.exec(tsCode);
	if (!m) {
		re = new RegExp(String.raw`\btype\s+${escapeRegExp(typeName)}\b\s*(?:<[^>]*?>)?\s*=`, 'm');
		m = re.exec(tsCode);
	}
	if (!m) return undefined;
	const start = m.index + m[0].length;
	const end = scanToTopLevelSemicolon(tsCode, start);
	if (end === -1) return undefined;
	return tsCode.slice(start, end).trim();
}

function scanToTopLevelSemicolon(code: string, startIndex: number): number {
	let depthParens = 0;
	let depthBraces = 0;
	let depthBrackets = 0;
	let depthAngles = 0;
	let inString: '"' | "'" | '`' | null = null;
	let inLineComment = false;
	let inBlockComment = false;
	for (let i = startIndex; i < code.length; i++) {
		const ch = code[i];
		const next = i + 1 < code.length ? code[i + 1] : '';
		const prev = i > 0 ? code[i - 1] : '';

		if (inLineComment) {
			if (ch === '\n') inLineComment = false;
			continue;
		}
		if (inBlockComment) {
			if (ch === '*' && next === '/') {
				inBlockComment = false;
				i++;
			}
			continue;
		}

		// comment start
		if (!inString && ch === '/' && next === '/') {
			inLineComment = true;
			i++;
			continue;
		}
		if (!inString && ch === '/' && next === '*') {
			inBlockComment = true;
			i++;
			continue;
		}

		if (inString) {
			if (ch === inString && prev !== '\\') inString = null;
			continue;
		}
		if (ch === '"' || ch === "'" || ch === '`') {
			inString = ch;
			continue;
		}

		switch (ch) {
			case '(':
				depthParens++;
				break;
			case ')':
				depthParens = Math.max(0, depthParens - 1);
				break;
			case '{':
				depthBraces++;
				break;
			case '}':
				depthBraces = Math.max(0, depthBraces - 1);
				break;
			case '[':
				depthBrackets++;
				break;
			case ']':
				depthBrackets = Math.max(0, depthBrackets - 1);
				break;
			case '<':
				depthAngles++;
				break;
			case '>':
				depthAngles = Math.max(0, depthAngles - 1);
				break;
			case ';':
				if (
					depthParens === 0 &&
					depthBraces === 0 &&
					depthBrackets === 0 &&
					depthAngles === 0
				)
					return i;
				break;
			default:
				break;
		}
	}
	return -1;
}

function parseTypeMembers(
	membersText: string
): { name: string; typeText: string; optional: boolean; description?: string }[] {
	const members: { name: string; typeText: string; optional: boolean; description?: string }[] =
		[];
	// Capture JSDoc and property; ignores methods/index signatures
	const propRe = /(\/\*\*[\s\S]*?\*\/)?\s*([A-Za-z_][\w]*)\s*(\?)?\s*:\s*([^;]+);/g;
	let m: RegExpExecArray | null;
	while ((m = propRe.exec(membersText)) !== null) {
		const jsdoc = m[1] ? m[1] : undefined;
		const name = m[2];
		const optional = Boolean(m[3]);
		const typeText = m[4].trim();
		const description = jsdoc ? extractJsDocSummary(jsdoc) : undefined;
		members.push({ name, typeText, optional, description });
	}
	return members;
}

function extractJsDocSummary(jsdoc: string): string | undefined {
	// Remove /** */ and leading *
	const inner = jsdoc.replace(/^\s*\/\*\*\s*/, '').replace(/\s*\*\/\s*$/, '');
	const lines = inner
		.split(/\r?\n/)
		.map((l) => l.replace(/^\s*\*\s?/, '').trim())
		.filter((l) => l.length > 0);
	return lines.join(' ');
}

function splitIntersection(typeRhs: string): string[] {
	return splitTopLevel(typeRhs, '&');
}

function splitTopLevel(input: string, sep: ',' | '&'): string[] {
	const parts: string[] = [];
	let depthParens = 0;
	let depthBraces = 0;
	let depthBrackets = 0;
	let depthAngles = 0;
	let current = '';
	let inString: '"' | "'" | '`' | null = null;
	for (let i = 0; i < input.length; i++) {
		const ch = input[i];
		const prev = i > 0 ? input[i - 1] : '';
		if (inString) {
			current += ch;
			if (ch === inString && prev !== '\\') inString = null;
			continue;
		}
		if (ch === '"' || ch === "'" || ch === '`') {
			inString = ch;
			current += ch;
			continue;
		}
		switch (ch) {
			case '(':
				depthParens++;
				break;
			case ')':
				depthParens = Math.max(0, depthParens - 1);
				break;
			case '{':
				depthBraces++;
				break;
			case '}':
				depthBraces = Math.max(0, depthBraces - 1);
				break;
			case '[':
				depthBrackets++;
				break;
			case ']':
				depthBrackets = Math.max(0, depthBrackets - 1);
				break;
			case '<':
				depthAngles++;
				break;
			case '>':
				depthAngles = Math.max(0, depthAngles - 1);
				break;
			default:
				break;
		}
		if (
			depthParens === 0 &&
			depthBraces === 0 &&
			depthBrackets === 0 &&
			depthAngles === 0 &&
			ch === sep
		) {
			parts.push(current);
			current = '';
			continue;
		}
		current += ch;
	}
	if (current.trim()) parts.push(current);
	return parts;
}

function splitOnce(text: string, delimiter: string): [string, string | undefined] {
	const idx = text.indexOf(delimiter);
	if (idx === -1) return [text, undefined];
	return [text.slice(0, idx), text.slice(idx + delimiter.length)];
}

function escapeRegExp(s: string): string {
	return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function buildComment(input: {
	filePath: string;
	existingDescription: string;
	inherits: string[];
	props: PropDoc[];
}): string {
	const fileName = path.basename(input.filePath);
	const title = fileName.replace(/\.svelte$/i, '');
	const description = escapeAngle(input.existingDescription.trim() || 'no description yet');

	const inheritsLine =
		input.inherits.length > 0
			? `#### Inherits: ${input.inherits.map((t) => wrapCode(t.trim())).join(' & ')}`
			: '';

	const propLines = input.props.map((p) => {
		const requiredMark = p.optional ? '' : '! ';
		const bindMark = p.bindable ? '$ ' : '';
		const namePart = `${requiredMark}${bindMark}${p.name}`.trimStart();
		const typePart = wrapCode(sanitizeInline(p.typeText), '**');
		const defaultVal = normalizeDefaultForDisplay(p.defaultText);
		const defaultPart = defaultVal ? ` = ${wrapCode(defaultVal)}` : '';
		const desc = p.description ? ` — ${sanitizeInline(stripRequiredHint(p.description))}` : '';
		return `- ${wrapCode(namePart)} ${typePart}${defaultPart}${desc}`;
	});

	const out: string[] = [START_MARK, `## ${title}`, description, '### Props'];
	if (inheritsLine) out.push(inheritsLine);
	out.push(...propLines, '-->');
	return out.join('\n');
}

function sanitizeInline(text: string): string {
	// Avoid newlines inside bullet lines
	return text.replace(/\s+/g, ' ').trim();
}

function escapeAngle(text: string): string {
	return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function wrapCode(text: string, char: string = '`'): string {
	return char + text + char;
}

function normalizeDefaultForDisplay(defaultText: string | undefined): string | undefined {
	if (!defaultText) return undefined;
	const trimmed = defaultText.trim().replace(/;$/, '');
	const bindMatch = /\$bindable\s*\(([\s\S]*)\)\s*/.exec(trimmed);
	const core = bindMatch ? bindMatch[1].trim() : trimmed;
	// strip quotes for simple literals
	const str = /^(?:['"`])(.*)(?:['"`])$/.exec(core);
	return str ? str[1] : core;
}

function stripRequiredHint(text: string): string {
	return text.replace(/\(\s*required\s*\)/gi, '').trim();
}

function insertOrUpdateComment(source: string, newComment: string): string {
	// Replace everything before the first <script lang="ts"> with the new block.
	const scriptOpen = /<script\s+[^>]*lang\s*=\s*["']ts["'][^>]*>/i;
	const firstScriptIdx = source.search(scriptOpen);
	const lm = /^(\uFEFF)?\s*/.exec(source);
	const leadingWs = lm ? lm[0] : '';
	if (firstScriptIdx !== -1) {
		// If there was any content before, discard it and insert our block
		const after = source.slice(firstScriptIdx);
		return `${leadingWs}${newComment}\n${after}`;
	}
	// If no script found, just prepend
	const rest = source.slice(leadingWs.length);
	return `${leadingWs}${newComment}\n${rest}`;
}

function extractDescriptionFromComment(raw: string): string {
	// New format: Description is the text between the first '## <Title>' line and the '### Props' heading
	// Fallback: if not found, return empty to let caller default to 'no description yet'
	// Find the first '## ' heading
	let idx = raw.indexOf('\n## ');
	if (idx === -1) idx = raw.indexOf('## '); // handle if it's the very start
	if (idx === -1) return '';
	const headerLineEnd = raw.indexOf('\n', idx + 1);
	if (headerLineEnd === -1) return '';
	const afterHeader = raw.slice(headerLineEnd + 1);
	const propsIdx = afterHeader.indexOf('\n### Props');
	const section = propsIdx === -1 ? afterHeader : afterHeader.slice(0, propsIdx);
	const cleaned = section.replace(/^\s+|\s+$/g, '').replace(/<!--[\s\S]*?-->/g, '');
	return cleaned.trim();
}

// (helpers removed after simplifying replacement logic)

function dedupe<T>(arr: T[]): T[] {
	return Array.from(new Set(arr));
}

// Execute
void main();
